<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Games Hub - myOnsite Healthcare</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 200, 255, 0.3) 0%, transparent 50%),
                linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #e2e8f0;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 30% 70%, rgba(120, 119, 198, 0.15) 0%, transparent 70%),
                radial-gradient(circle at 70% 30%, rgba(255, 119, 198, 0.15) 0%, transparent 70%);
            animation: liquidFlow 20s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes liquidFlow {
            0%, 100% { 
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            33% { 
                transform: translate(-20px, -30px) scale(1.1);
                opacity: 0.8;
            }
            66% { 
                transform: translate(20px, 30px) scale(0.9);
                opacity: 0.9;
            }
        }

        .game-container {
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.09) 0%,
                rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 32px;
            padding: 2.5rem;
            box-shadow: 
                0 25px 45px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 1px 3px rgba(0, 0, 0, 0.3);
            text-align: center;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.320, 1);
            min-width: 320px;
        }

        .main-menu-container {
            max-width: 700px;
            width: 90%;
        }

        .tic-tac-toe-container {
            max-width: 520px;
            width: 90%;
        }

        .solitaire-container {
            max-width: 1200px;
            width: 95%;
            padding: 1.5rem;
        }

        .chess-container {
            max-width: 900px;
            width: 95%;
            padding: 2rem;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.1) 0%,
                transparent 50%,
                rgba(0, 0, 0, 0.05) 100%);
            border-radius: 32px;
            pointer-events: none;
            z-index: -1;
        }

        .game-container::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, 
                transparent 30%, 
                rgba(255, 255, 255, 0.05) 50%, 
                transparent 70%);
            animation: liquidSweep 8s linear infinite;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes liquidSweep {
            0% { transform: translate(-100%, -100%) rotate(45deg); }
            100% { transform: translate(100%, 100%) rotate(45deg); }
        }

        h1 {
            font-size: 2.8rem;
            font-weight: 900;
            margin-bottom: 2rem;
            background: linear-gradient(135deg, #e2e8f0, #94a3b8, #e2e8f0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 10;
        }

        /* Main Menu Styles */
        .main-menu {
            display: block;
        }

        .game-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .game-card {
            background: linear-gradient(145deg, 
                rgba(120, 197, 255, 0.15) 0%,
                rgba(159, 122, 234, 0.15) 100%);
            border: 1px solid rgba(120, 197, 255, 0.3);
            border-radius: 24px;
            padding: 2rem;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.320, 1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            transition: left 0.6s ease;
        }

        .game-card:hover::before {
            left: 100%;
        }

        .game-card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.4),
                0 0 32px rgba(120, 197, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            background: linear-gradient(145deg, 
                rgba(120, 197, 255, 0.25) 0%,
                rgba(159, 122, 234, 0.25) 100%);
            border-color: rgba(120, 197, 255, 0.5);
        }

        .game-card h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #e2e8f0;
        }

        .game-card p {
            color: rgba(255, 255, 255, 0.8);
            line-height: 1.6;
        }

        .game-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            display: block;
        }

        /* Common Game Elements */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .current-mode {
            font-size: 1.2rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .back-btn {
            padding: 0.8rem 1.5rem;
            font-size: 0.9rem;
            font-weight: 600;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            background: linear-gradient(145deg, 
                rgba(255, 75, 75, 0.15) 0%,
                rgba(220, 38, 38, 0.15) 100%);
            border: 1px solid rgba(255, 75, 75, 0.3);
            color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: linear-gradient(145deg, 
                rgba(255, 75, 75, 0.25) 0%,
                rgba(220, 38, 38, 0.25) 100%);
            border-color: rgba(255, 75, 75, 0.5);
            transform: translateY(-2px);
        }

        .btn {
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 28px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.320, 1);
            background: linear-gradient(145deg, 
                rgba(120, 197, 255, 0.15) 0%,
                rgba(159, 122, 234, 0.15) 100%);
            border: 1px solid rgba(120, 197, 255, 0.3);
            color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            transition: left 0.6s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.4),
                0 0 24px rgba(120, 197, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            background: linear-gradient(145deg, 
                rgba(120, 197, 255, 0.25) 0%,
                rgba(159, 122, 234, 0.25) 100%);
            border-color: rgba(120, 197, 255, 0.5);
            color: white;
        }

        /* Tic Tac Toe Styles */
        .tic-tac-toe-game,
        .solitaire-game,
        .chess-game {
            display: none;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 2rem auto;
            max-width: 360px;
            padding: 20px;
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.2) 0%,
                rgba(255, 255, 255, 0.05) 100%);
            border-radius: 24px;
            box-shadow: 
                inset 0 4px 8px rgba(0, 0, 0, 0.3),
                0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .cell {
            width: 100px;
            height: 100px;
            border: none;
            border-radius: 20px;
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.320, 1);
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.1) 0%,
                transparent 50%,
                rgba(0, 0, 0, 0.1) 100%);
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .cell:hover::before {
            opacity: 1;
        }

        .cell:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 
                0 12px 36px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(120, 197, 255, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.15) 0%,
                rgba(120, 197, 255, 0.1) 100%);
            border-color: rgba(120, 197, 255, 0.4);
        }

        .cell.winner {
            background: linear-gradient(145deg, 
                rgba(34, 197, 94, 0.3) 0%,
                rgba(22, 163, 74, 0.3) 100%);
            border-color: rgba(34, 197, 94, 0.6);
            color: #22c55e;
            animation: liquidWinPulse 0.6s ease-in-out;
            box-shadow: 
                0 0 30px rgba(34, 197, 94, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        @keyframes liquidWinPulse {
            0%, 100% { 
                transform: scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.1);
                filter: brightness(1.3);
            }
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .mode-btn {
            padding: 1.2rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.23, 1, 0.320, 1);
            background: linear-gradient(145deg, 
                rgba(159, 122, 234, 0.15) 0%,
                rgba(236, 72, 153, 0.15) 100%);
            border: 1px solid rgba(159, 122, 234, 0.3);
            color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            position: relative;
            overflow: hidden;
        }

        .mode-btn:hover {
            transform: translateY(-4px) scale(1.05);
            background: linear-gradient(145deg, 
                rgba(159, 122, 234, 0.25) 0%,
                rgba(236, 72, 153, 0.25) 100%);
            border-color: rgba(159, 122, 234, 0.5);
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.4),
                0 0 24px rgba(159, 122, 234, 0.3);
        }

        /* Chess Styles */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            margin: 2rem auto;
            width: 480px;
            height: 480px;
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            overflow: hidden;
            background: linear-gradient(145deg, 
                rgba(0, 0, 0, 0.2) 0%,
                rgba(255, 255, 255, 0.05) 100%);
            box-shadow: 
                0 25px 45px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .chess-square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .chess-square.light {
            background: linear-gradient(145deg, 
                rgba(240, 217, 181, 0.9) 0%,
                rgba(222, 184, 135, 0.9) 100%);
        }

        .chess-square.dark {
            background: linear-gradient(145deg, 
                rgba(181, 136, 99, 0.9) 0%,
                rgba(139, 69, 19, 0.9) 100%);
        }

        .chess-square:hover {
            background: linear-gradient(145deg, 
                rgba(120, 197, 255, 0.4) 0%,
                rgba(159, 122, 234, 0.4) 100%);
            box-shadow: 0 0 20px rgba(120, 197, 255, 0.5);
        }

        .chess-square.selected {
            background: linear-gradient(145deg, 
                rgba(34, 197, 94, 0.6) 0%,
                rgba(22, 163, 74, 0.6) 100%);
            box-shadow: 0 0 25px rgba(34, 197, 94, 0.7);
        }

        .chess-square.possible-move {
            background: linear-gradient(145deg, 
                rgba(255, 193, 7, 0.5) 0%,
                rgba(255, 152, 0, 0.5) 100%);
        }

        .chess-piece {
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
            user-select: none;
            -webkit-user-select: none;
        }

        /* Solitaire Styles - Enhanced */
        .solitaire-board {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
            margin: 2rem 0;
            min-height: 600px;
        }

        .card-column {
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.05) 0%,
                rgba(255, 255, 255, 0.02) 100%);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            min-height: 150px;
            padding: 8px;
            position: relative;
            transition: all 0.3s ease;
        }

        .card-column.drop-zone {
            border-color: rgba(120, 197, 255, 0.6);
            background: linear-gradient(145deg, 
                rgba(120, 197, 255, 0.1) 0%,
                rgba(159, 122, 234, 0.1) 100%);
            box-shadow: 0 0 20px rgba(120, 197, 255, 0.3);
        }

        .card {
            width: 100px;
            height: 140px;
            border-radius: 16px;
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.98) 0%,
                rgba(248, 250, 252, 0.98) 50%,
                rgba(241, 245, 249, 0.98) 100%);
            border: 3px solid rgba(0, 0, 0, 0.08);
            box-shadow: 
                0 8px 24px rgba(0, 0, 0, 0.15),
                0 4px 12px rgba(0, 0, 0, 0.1),
                inset 0 2px 0 rgba(255, 255, 255, 0.9),
                inset 0 -1px 0 rgba(0, 0, 0, 0.05);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin: 3px 0;
            position: relative;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.320, 1);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            user-select: none;
            -webkit-user-select: none;
            font-family: 'SF Pro Display', 'Inter', system-ui, sans-serif;
        }

        .card.face-down {
            background: linear-gradient(145deg, 
                rgba(30, 58, 138, 0.95) 0%,
                rgba(37, 99, 235, 0.95) 30%,
                rgba(29, 78, 216, 0.95) 70%,
                rgba(15, 29, 69, 0.95) 100%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .card.face-down::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.1) 0px,
                rgba(255, 255, 255, 0.1) 2px,
                transparent 2px,
                transparent 8px
            );
            border-radius: 16px;
        }

        .card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 
                0 12px 32px rgba(0, 0, 0, 0.2),
                0 8px 24px rgba(0, 0, 0, 0.15),
                inset 0 2px 0 rgba(255, 255, 255, 0.95),
                0 0 20px rgba(120, 197, 255, 0.15);
            border-color: rgba(120, 197, 255, 0.2);
        }

        .card.red {
            color: #dc2626;
        }

        .card.black {
            color: #1f2937;
        }

        .card-value {
            font-size: 1.4rem;
            font-weight: 700;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            letter-spacing: -0.02em;
        }

        .card-suit {
            font-size: 2rem;
            filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.1));
        }

        /* Stats and Controls */
        .game-stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .stat-item {
            background: linear-gradient(145deg, 
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 1rem 1.5rem;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #22c55e;
            text-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }

        .stat-label {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.25rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .game-container {
                padding: 1.5rem;
                margin: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .game-selection {
                grid-template-columns: 1fr;
            }
            
            .chess-board {
                width: 320px;
                height: 320px;
            }
            
            .chess-square {
                width: 40px;
                height: 40px;
                font-size: 1.8rem;
            }
            
            .card {
                width: 80px;
                height: 110px;
            }
            
            .solitaire-board {
                grid-template-columns: repeat(4, 1fr);
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div class="game-container main-menu-container" id="main-menu">
        <h1>🎮 AI Games Hub</h1>
        <div style="color: rgba(255,255,255,0.7); margin-bottom: 2rem; font-size: 1.1rem;">
            by myOnsite Healthcare
        </div>
        <div class="game-selection">
            <div class="game-card" onclick="GameManager.startTicTacToe()">
                <div class="game-icon">⭕</div>
                <h3>Tic Tac Toe Pro</h3>
                <p>Classic strategy game with AI opponents of varying difficulty levels. Features hint system and score tracking.</p>
            </div>
            <div class="game-card" onclick="GameManager.startSolitaire()">
                <div class="game-icon">🃏</div>
                <h3>Klondike Solitaire</h3>
                <p>The classic card game with drag-and-drop mechanics, auto-complete, and beautiful liquid glass card animations.</p>
            </div>
            <div class="game-card" onclick="GameManager.startChess()">
                <div class="game-icon">♚</div>
                <h3>Chess Master</h3>
                <p>Professional chess game with AI engine, move validation, and stunning liquid glass piece animations.</p>
            </div>
        </div>
    </div>

    <!-- Tic Tac Toe Game -->
    <div class="game-container tic-tac-toe-container tic-tac-toe-game" id="tic-tac-toe-game">
        <div class="game-header">
            <div class="current-mode" id="tic-tac-toe-mode">Tic Tac Toe Pro</div>
            <button class="back-btn" onclick="GameManager.showMainMenu()">← Back to Hub</button>
        </div>
        
        <!-- Game Mode Selection -->
        <div class="game-modes" id="ttt-game-modes">
            <h3>Choose Your Game Mode</h3>
            <div class="mode-buttons">
                <button class="mode-btn" onclick="TicTacToe.selectMode('pvp')">👥 Player vs Player</button>
                <button class="mode-btn" onclick="TicTacToe.selectMode('easy')">🤖 vs AI (Easy)</button>
                <button class="mode-btn" onclick="TicTacToe.selectMode('medium')">🧠 vs AI (Medium)</button>
                <button class="mode-btn" onclick="TicTacToe.selectMode('hard')">💀 vs AI (Hard)</button>
            </div>
        </div>

        <!-- Game Interface -->
        <div class="game-interface" id="ttt-game-interface" style="display: none;">
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-value" id="ttt-current-player">X</div>
                    <div class="stat-label" id="ttt-player-indicator">Current Player</div>
                </div>
            </div>
            
            <div class="game-status" id="ttt-game-status" style="font-size: 1.4rem; margin: 1rem 0; min-height: 2rem;"></div>
            
            <div id="ttt-ai-thinking" style="display: none; color: #78c5ff; margin: 1rem 0;">🤖 AI is thinking...</div>

            <div class="game-board" id="ttt-game-board">
                <button class="cell" onclick="TicTacToe.makeMove(0)"></button>
                <button class="cell" onclick="TicTacToe.makeMove(1)"></button>
                <button class="cell" onclick="TicTacToe.makeMove(2)"></button>
                <button class="cell" onclick="TicTacToe.makeMove(3)"></button>
                <button class="cell" onclick="TicTacToe.makeMove(4)"></button>
                <button class="cell" onclick="TicTacToe.makeMove(5)"></button>
                <button class="cell" onclick="TicTacToe.makeMove(6)"></button>
                <button class="cell" onclick="TicTacToe.makeMove(7)"></button>
                <button class="cell" onclick="TicTacToe.makeMove(8)"></button>
            </div>

            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin: 2rem 0;">
                <button class="btn" onclick="TicTacToe.resetGame()">🔄 New Game</button>
                <button class="btn" id="ttt-hint-btn" onclick="TicTacToe.showHint()" style="display: none;">💡 Hint</button>
                <button class="btn" onclick="TicTacToe.resetScore()">📊 Reset Score</button>
                <button class="btn" onclick="TicTacToe.showModes()">⚙️ Change Mode</button>
            </div>

            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-value" id="ttt-score-x">0</div>
                    <div class="stat-label">Player X</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="ttt-score-draw">0</div>
                    <div class="stat-label">Draws</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="ttt-score-o">0</div>
                    <div class="stat-label">Player O</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Chess Game -->
    <div class="game-container chess-container chess-game" id="chess-game">
        <div class="game-header">
            <div class="current-mode">♚ Chess Master</div>
            <button class="back-btn" onclick="GameManager.showMainMenu()">← Back to Hub</button>
        </div>

        <div class="game-stats">
            <div class="stat-item">
                <div class="stat-value" id="chess-current-player">White</div>
                <div class="stat-label">Current Player</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="chess-move-count">0</div>
                <div class="stat-label">Moves</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="chess-captured">0</div>
                <div class="stat-label">Captured</div>
            </div>
        </div>

        <div class="chess-board" id="chess-board">
            <!-- Chess squares will be generated by JavaScript -->
        </div>

        <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin: 2rem 0;">
            <button class="btn" onclick="Chess.newGame()">🔄 New Game</button>
            <button class="btn" onclick="Chess.undoMove()">↶ Undo Move</button>
            <button class="btn" onclick="Chess.toggleAI()">🤖 <span id="chess-ai-status">AI: OFF</span></button>
        </div>

        <div id="chess-status" style="text-align: center; margin: 1rem 0; font-size: 1.2rem; min-height: 1.5rem;"></div>
    </div>

    <!-- Solitaire Game -->
    <div class="game-container solitaire-container solitaire-game" id="solitaire-game">
        <div class="game-header">
            <div class="current-mode">🃏 Klondike Solitaire</div>
            <button class="back-btn" onclick="GameManager.showMainMenu()">← Back to Hub</button>
        </div>

        <div class="game-stats">
            <div class="stat-item">
                <div class="stat-value" id="sol-moves-count">0</div>
                <div class="stat-label">Moves</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="sol-score-count">0</div>
                <div class="stat-label">Score</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="sol-time-count">00:00</div>
                <div class="stat-label">Time</div>
            </div>
        </div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem; flex-wrap: wrap; gap: 1rem;">
            <div style="display: flex; gap: 10px; align-items: center;">
                <div style="width: 110px; height: 150px; border-radius: 20px; border: 3px dashed rgba(255, 255, 255, 0.4); display: flex; align-items: center; justify-content: center; cursor: pointer; backdrop-filter: blur(10px);" 
                     id="sol-stock" onclick="Solitaire.drawCard()">
                    <div style="color: rgba(255,255,255,0.6); font-size: 1.1rem; font-weight: 600;">Stock</div>
                </div>
                <div style="width: 110px; height: 150px; border-radius: 20px; border: 3px dashed rgba(255, 255, 255, 0.4); display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px);" 
                     id="sol-waste"></div>
            </div>
            <div style="display: flex; gap: 10px;">
                <div class="foundation" id="sol-foundation-0" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)">♠</div>
                <div class="foundation" id="sol-foundation-1" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)">♥</div>
                <div class="foundation" id="sol-foundation-2" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)">♣</div>
                <div class="foundation" id="sol-foundation-3" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)">♦</div>
            </div>
        </div>

        <div class="solitaire-board" id="sol-solitaire-board">
            <div class="card-column" id="sol-column-0" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)"></div>
            <div class="card-column" id="sol-column-1" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)"></div>
            <div class="card-column" id="sol-column-2" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)"></div>
            <div class="card-column" id="sol-column-3" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)"></div>
            <div class="card-column" id="sol-column-4" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)"></div>
            <div class="card-column" id="sol-column-5" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)"></div>
            <div class="card-column" id="sol-column-6" ondrop="Solitaire.dropCard(event)" ondragover="Solitaire.allowDrop(event)"></div>
        </div>

        <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin: 2rem 0;">
            <button class="btn" onclick="Solitaire.newGame()">🔄 New Game</button>
            <button class="btn" onclick="Solitaire.autoComplete()">✨ Auto Complete</button>
            <button class="btn" onclick="Solitaire.undoMove()">↶ Undo</button>
        </div>
    </div>

    <script>
        // Game Manager - Central Navigation
        const GameManager = {
            showMainMenu() {
                document.getElementById('main-menu').style.display = 'block';
                document.getElementById('tic-tac-toe-game').style.display = 'none';
                document.getElementById('solitaire-game').style.display = 'none';
                document.getElementById('chess-game').style.display = 'none';
            },

            startTicTacToe() {
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('tic-tac-toe-game').style.display = 'block';
                document.getElementById('solitaire-game').style.display = 'none';
                document.getElementById('chess-game').style.display = 'none';
                TicTacToe.showModes();
            },

            startSolitaire() {
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('tic-tac-toe-game').style.display = 'none';
                document.getElementById('solitaire-game').style.display = 'block';
                document.getElementById('chess-game').style.display = 'none';
                Solitaire.newGame();
            },

            startChess() {
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('tic-tac-toe-game').style.display = 'none';
                document.getElementById('solitaire-game').style.display = 'none';
                document.getElementById('chess-game').style.display = 'block';
                Chess.initGame();
            }
        };

        // Professional Tic Tac Toe Game Logic with Advanced AI
        const TicTacToe = {
            board: Array(9).fill(''),
            currentPlayer: 'X',
            gameActive: true,
            gameMode: 'pvp',
            isAIGame: false,
            humanPlayer: 'X',
            aiPlayer: 'O',
            scores: { X: 0, O: 0, draw: 0 },
            gameStats: {
                gamesPlayed: 0,
                totalMoves: 0,
                averageGameLength: 0,
                winStreaks: { current: 0, best: 0 },
                aiWins: { easy: 0, medium: 0, hard: 0 },
                playerMoves: [],
                sessionStartTime: Date.now()
            },
            aiPersonalities: {
                easy: {
                    name: 'Rookie',
                    description: 'Makes random moves with occasional strategy',
                    errorRate: 0.7,
                    thinkingTime: 500,
                    personality: 'Makes beginner mistakes'
                },
                medium: {
                    name: 'Strategist',
                    description: 'Balances offense and defense',
                    errorRate: 0.3,
                    thinkingTime: 800,
                    personality: 'Thinks tactically'
                },
                hard: {
                    name: 'Grandmaster',
                    description: 'Perfect play with advanced analysis',
                    errorRate: 0.0,
                    thinkingTime: 1200,
                    personality: 'Plays flawlessly'
                }
            },
            winningConditions: [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ],
            moveHistory: [],
            soundEnabled: true,

            showModes() {
                document.getElementById('ttt-game-modes').style.display = 'block';
                document.getElementById('ttt-game-interface').style.display = 'none';
            },

            selectMode(mode) {
                this.gameMode = mode;
                this.isAIGame = mode !== 'pvp';
                
                document.getElementById('ttt-game-modes').style.display = 'none';
                document.getElementById('ttt-game-interface').style.display = 'block';
                
                const modeTexts = {
                    'pvp': 'Player vs Player',
                    'easy': `vs ${this.aiPersonalities.easy.name} (${this.aiPersonalities.easy.description})`,
                    'medium': `vs ${this.aiPersonalities.medium.name} (${this.aiPersonalities.medium.description})`,
                    'hard': `vs ${this.aiPersonalities.hard.name} (${this.aiPersonalities.hard.description})`
                };
                
                document.getElementById('tic-tac-toe-mode').innerHTML = modeTexts[mode];
                document.getElementById('ttt-hint-btn').style.display = this.isAIGame ? 'inline-block' : 'none';
                
                // Reset game stats for new mode
                this.gameStats.gamesPlayed = 0;
                this.gameStats.totalMoves = 0;
                this.gameStats.winStreaks.current = 0;
                this.gameStats.sessionStartTime = Date.now();
                
                this.resetGame();
            },

            makeMove(index) {
                if (!this.gameActive || this.board[index] !== '') return;
                
                this.board[index] = this.currentPlayer;
                const cell = document.querySelectorAll('#ttt-game-board .cell')[index];
                
                // Professional move animation with liquid glass effect
                cell.style.transform = 'scale(0)';
                cell.style.transition = 'transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                
                setTimeout(() => {
                    cell.textContent = this.currentPlayer;
                    cell.style.color = this.currentPlayer === 'X' ? '#e53e3e' : '#3182ce';
                    cell.style.textShadow = '0 0 10px currentColor';
                    cell.style.transform = 'scale(1)';
                    
                    // Add glow effect
                    cell.style.boxShadow = `0 0 20px ${this.currentPlayer === 'X' ? '#e53e3e' : '#3182ce'}40`;
                    setTimeout(() => {
                        cell.style.boxShadow = '';
                        cell.style.textShadow = '0 2px 8px rgba(0, 0, 0, 0.5)';
                    }, 500);
                }, 50);
                
                // Record move in history
                if (!this.isAIGame || this.currentPlayer === this.humanPlayer) {
                    this.addMoveToHistory(index, this.currentPlayer);
                }
                
                // Play sound feedback
                this.playSound('move');
                
                if (this.checkWinner()) {
                    this.handleGameEnd('win');
                    return;
                }
                
                if (this.checkDraw()) {
                    this.handleGameEnd('draw');
                    return;
                }
                
                this.switchPlayer();
                
                if (this.isAIGame && this.currentPlayer === this.aiPlayer) {
                    const personality = this.aiPersonalities[this.gameMode];
                    document.getElementById('ttt-ai-thinking').style.display = 'block';
                    document.getElementById('ttt-ai-thinking').innerHTML = `🤖 ${personality.name} is ${personality.personality.toLowerCase()}...`;
                    
                    setTimeout(() => {
                        this.makeAIMove();
                        document.getElementById('ttt-ai-thinking').style.display = 'none';
                    }, personality.thinkingTime);
                }
            },

            makeAIMove() {
                if (!this.gameActive) return;
                
                const personality = this.aiPersonalities[this.gameMode];
                const shouldMakeError = Math.random() < personality.errorRate;
                
                let move;
                if (shouldMakeError && this.gameMode !== 'hard') {
                    // Make a suboptimal move based on personality
                    move = this.gameMode === 'easy' ? this.getRandomMove() : this.getMediumMove();
                } else {
                    // Make optimal move
                    switch (this.gameMode) {
                        case 'easy':
                            move = Math.random() < 0.3 ? this.getBestMoveAlphaBeta() : this.getRandomMove();
                            break;
                        case 'medium':
                            move = this.getMediumMove();
                            break;
                        case 'hard':
                            move = this.getBestMoveAlphaBeta();
                            break;
                    }
                }
                
                if (move !== -1) {
                    this.addMoveToHistory(move, this.aiPlayer);
                    this.makeMove(move);
                    this.playSound('ai-move');
                }
            },

            getRandomMove() {
                const available = this.board.map((cell, index) => cell === '' ? index : null).filter(val => val !== null);
                return available.length > 0 ? available[Math.floor(Math.random() * available.length)] : -1;
            },

            getBestMove() {
                let bestScore = -Infinity;
                let bestMove = -1;
                
                for (let i = 0; i < 9; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = this.aiPlayer;
                        let score = this.minimax(this.board, 0, false);
                        this.board[i] = '';
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = i;
                        }
                    }
                }
                
                return bestMove;
            },

            // Advanced AI with Alpha-Beta Pruning for Professional Performance
            getBestMoveAlphaBeta() {
                let bestScore = -Infinity;
                let bestMove = -1;
                const depth = 9; // Maximum search depth for perfect play
                
                for (let i = 0; i < 9; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = this.aiPlayer;
                        let score = this.minimaxAlphaBeta(this.board, depth - 1, -Infinity, Infinity, false);
                        this.board[i] = '';
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = i;
                        }
                    }
                }
                
                return bestMove;
            },

            // Minimax with Alpha-Beta Pruning - Professional AI Algorithm
            minimaxAlphaBeta(boardState, depth, alpha, beta, isMaximizing) {
                const result = this.checkWinnerForBoard(boardState);
                
                if (result === this.aiPlayer) return 10 + depth;
                if (result === this.humanPlayer) return -10 - depth;
                if (boardState.every(cell => cell !== '') || depth === 0) return 0;
                
                if (isMaximizing) {
                    let maxEval = -Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (boardState[i] === '') {
                            boardState[i] = this.aiPlayer;
                            const eval = this.minimaxAlphaBeta(boardState, depth - 1, alpha, beta, false);
                            boardState[i] = '';
                            maxEval = Math.max(maxEval, eval);
                            alpha = Math.max(alpha, eval);
                            if (beta <= alpha) break; // Alpha-beta pruning
                        }
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (boardState[i] === '') {
                            boardState[i] = this.humanPlayer;
                            const eval = this.minimaxAlphaBeta(boardState, depth - 1, alpha, beta, true);
                            boardState[i] = '';
                            minEval = Math.min(minEval, eval);
                            beta = Math.min(beta, eval);
                            if (beta <= alpha) break; // Alpha-beta pruning
                        }
                    }
                    return minEval;
                }
            },

            // Professional Move History and Analytics
            addMoveToHistory(move, player) {
                this.moveHistory.push({
                    move: move,
                    player: player,
                    timestamp: Date.now(),
                    boardState: [...this.board]
                });
                this.gameStats.totalMoves++;
            },

            // Professional Sound System
            playSound(type) {
                if (!this.soundEnabled) return;
                
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch (type) {
                    case 'move':
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        break;
                    case 'ai-move':
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                        break;
                    case 'win':
                        // Victory fanfare
                        const notes = [523, 659, 783, 1046];
                        notes.forEach((freq, i) => {
                            setTimeout(() => {
                                const osc = audioContext.createOscillator();
                                const gain = audioContext.createGain();
                                osc.connect(gain);
                                gain.connect(audioContext.destination);
                                osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                                osc.start();
                                osc.stop(audioContext.currentTime + 0.3);
                            }, i * 100);
                        });
                        return;
                    case 'draw':
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                        break;
                }
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.2);
            },

            minimax(boardState, depth, isMaximizing) {
                if (this.checkWinnerForBoard(boardState)) {
                    return isMaximizing ? -10 + depth : 10 - depth;
                }
                
                if (boardState.every(cell => cell !== '')) {
                    return 0;
                }
                
                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (boardState[i] === '') {
                            boardState[i] = this.aiPlayer;
                            let score = this.minimax(boardState, depth + 1, false);
                            boardState[i] = '';
                            bestScore = Math.max(score, bestScore);
                        }
                    }
                    return bestScore;
                } else {
                    let bestScore = Infinity;
                    for (let i = 0; i < 9; i++) {
                        if (boardState[i] === '') {
                            boardState[i] = this.humanPlayer;
                            let score = this.minimax(boardState, depth + 1, true);
                            boardState[i] = '';
                            bestScore = Math.min(score, bestScore);
                        }
                    }
                    return bestScore;
                }
            },

            getMediumMove() {
                // Try to win
                for (let i = 0; i < 9; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = this.aiPlayer;
                        if (this.checkWinnerForBoard(this.board)) {
                            this.board[i] = '';
                            return i;
                        }
                        this.board[i] = '';
                    }
                }
                
                // Block player win
                for (let i = 0; i < 9; i++) {
                    if (this.board[i] === '') {
                        this.board[i] = this.humanPlayer;
                        if (this.checkWinnerForBoard(this.board)) {
                            this.board[i] = '';
                            return i;
                        }
                        this.board[i] = '';
                    }
                }
                
                // Take center
                if (this.board[4] === '') return 4;
                
                // Take corners
                const corners = [0, 2, 6, 8];
                const availableCorners = corners.filter(i => this.board[i] === '');
                if (availableCorners.length > 0) {
                    return availableCorners[Math.floor(Math.random() * availableCorners.length)];
                }
                
                return this.getRandomMove();
            },

            checkWinner() {
                return this.checkWinnerForBoard(this.board);
            },

            checkWinnerForBoard(boardState) {
                for (let condition of this.winningConditions) {
                    const [a, b, c] = condition;
                    if (boardState[a] && boardState[a] === boardState[b] && boardState[a] === boardState[c]) {
                        if (boardState === this.board) {
                            this.highlightWinningCells(condition);
                        }
                        return true;
                    }
                }
                return false;
            },

            highlightWinningCells(winningIndexes) {
                const cells = document.querySelectorAll('#ttt-game-board .cell');
                winningIndexes.forEach(index => {
                    cells[index].classList.add('winner');
                });
            },

            checkDraw() {
                return this.board.every(cell => cell !== '');
            },

            handleGameEnd(result) {
                this.gameActive = false;
                this.gameStats.gamesPlayed++;
                const statusElement = document.getElementById('ttt-game-status');
                
                if (result === 'win') {
                    this.scores[this.currentPlayer]++;
                    
                    // Professional victory animation
                    this.celebrateWin();
                    this.playSound('win');
                    
                    // Update analytics
                    if (this.isAIGame) {
                        if (this.currentPlayer === this.humanPlayer) {
                            this.gameStats.winStreaks.current++;
                            this.gameStats.winStreaks.best = Math.max(
                                this.gameStats.winStreaks.best, 
                                this.gameStats.winStreaks.current
                            );
                            statusElement.innerHTML = `🎉 Victory! Win Streak: ${this.gameStats.winStreaks.current}`;
                        } else {
                            this.gameStats.winStreaks.current = 0;
                            this.gameStats.aiWins[this.gameMode]++;
                            const personality = this.aiPersonalities[this.gameMode];
                            statusElement.innerHTML = `🤖 ${personality.name} Wins! ${personality.description}`;
                        }
                    } else {
                        statusElement.innerHTML = `🎉 Player ${this.currentPlayer} Wins!`;
                    }
                    
                    statusElement.style.color = '#22c55e';
                } else if (result === 'draw') {
                    this.scores.draw++;
                    this.gameStats.winStreaks.current = 0;
                    statusElement.textContent = "🤝 Strategic Draw!";
                    statusElement.style.color = '#f59e0b';
                    this.playSound('draw');
                }
                
                // Update game statistics
                this.gameStats.averageGameLength = this.gameStats.totalMoves / this.gameStats.gamesPlayed;
                this.updateScoreDisplay();
                this.updateAnalytics();
                
                setTimeout(() => {
                    this.resetGame();
                }, 4000);
            },

            // Professional victory celebration with particle effects
            celebrateWin() {
                const board = document.getElementById('ttt-game-board');
                
                // Create celebration particles
                for (let i = 0; i < 20; i++) {
                    const particle = document.createElement('div');
                    particle.style.position = 'absolute';
                    particle.style.width = '6px';
                    particle.style.height = '6px';
                    particle.style.backgroundColor = this.currentPlayer === 'X' ? '#e53e3e' : '#3182ce';
                    particle.style.borderRadius = '50%';
                    particle.style.pointerEvents = 'none';
                    particle.style.zIndex = '1000';
                    
                    const startX = Math.random() * board.offsetWidth;
                    const startY = Math.random() * board.offsetHeight;
                    particle.style.left = startX + 'px';
                    particle.style.top = startY + 'px';
                    
                    board.appendChild(particle);
                    
                    // Animate particle
                    particle.animate([
                        { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                        { 
                            transform: `translate(${(Math.random() - 0.5) * 200}px, ${-100 - Math.random() * 100}px) scale(0)`, 
                            opacity: 0 
                        }
                    ], {
                        duration: 1000 + Math.random() * 500,
                        easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
                    }).addEventListener('finish', () => particle.remove());
                }
            },

            // Professional analytics display
            updateAnalytics() {
                const sessionTime = (Date.now() - this.gameStats.sessionStartTime) / 1000 / 60; // minutes
                console.log('🎮 Professional Tic Tac Toe Analytics:', {
                    gamesPlayed: this.gameStats.gamesPlayed,
                    averageGameLength: this.gameStats.averageGameLength.toFixed(1),
                    winStreak: this.gameStats.winStreaks.current,
                    bestWinStreak: this.gameStats.winStreaks.best,
                    sessionDuration: sessionTime.toFixed(1) + ' minutes',
                    aiPerformance: this.gameStats.aiWins
                });
            },

            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
                this.updatePlayerDisplay();
            },

            updatePlayerDisplay() {
                document.getElementById('ttt-current-player').textContent = this.currentPlayer;
                document.getElementById('ttt-current-player').style.color = 
                    this.currentPlayer === 'X' ? '#e53e3e' : '#3182ce';
                
                if (this.isAIGame) {
                    document.getElementById('ttt-player-indicator').textContent = 
                        this.currentPlayer === this.humanPlayer ? 'Your Turn' : 'AI Turn';
                }
            },

            resetGame() {
                this.board = Array(9).fill('');
                this.currentPlayer = 'X';
                this.gameActive = true;
                document.getElementById('ttt-game-status').textContent = '';
                document.getElementById('ttt-game-status').style.color = 'rgba(255, 255, 255, 0.9)';
                document.getElementById('ttt-ai-thinking').style.display = 'none';

                const cells = document.querySelectorAll('#ttt-game-board .cell');
                cells.forEach(cell => {
                    cell.textContent = '';
                    cell.className = 'cell';
                });

                this.updatePlayerDisplay();
            },

            resetScore() {
                this.scores = { X: 0, O: 0, draw: 0 };
                this.updateScoreDisplay();
            },

            updateScoreDisplay() {
                document.getElementById('ttt-score-x').textContent = this.scores.X;
                document.getElementById('ttt-score-o').textContent = this.scores.O;
                document.getElementById('ttt-score-draw').textContent = this.scores.draw;
            },

            showHint() {
                if (!this.isAIGame || this.currentPlayer !== this.humanPlayer) return;
                
                const bestMove = this.getBestMove();
                if (bestMove !== -1) {
                    const cell = document.querySelectorAll('#ttt-game-board .cell')[bestMove];
                    const originalBg = cell.style.background;
                    const originalTransform = cell.style.transform;
                    
                    cell.style.background = 'linear-gradient(135deg, #ffd700, #ffed4e)';
                    cell.style.transform = 'scale(1.1)';
                    
                    setTimeout(() => {
                        cell.style.background = originalBg;
                        cell.style.transform = originalTransform;
                    }, 1500);
                }
            }
        };

        // Professional Chess Engine with Advanced Features
        const Chess = {
            board: [],
            currentPlayer: 'white',
            selectedSquare: null,
            possibleMoves: [],
            moveCount: 0,
            capturedPieces: { white: [], black: [] },
            aiEnabled: false,
            gameMode: 'human', // human, ai-easy, ai-medium, ai-hard
            
            // Professional chess state tracking
            gameState: {
                whiteKingMoved: false,
                blackKingMoved: false,
                whiteRooksMoved: { queenside: false, kingside: false },
                blackRooksMoved: { queenside: false, kingside: false },
                enPassantSquare: null,
                inCheck: false,
                checkmate: false,
                stalemate: false,
                fiftyMoveRule: 0,
                moveHistory: [],
                positionHistory: []
            },

            // Professional piece values for AI evaluation
            pieceValues: {
                'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000
            },

            // Professional opening book
            openingBook: {
                'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -': ['e2e4', 'd2d4', 'g1f3', 'c2c4'],
                'rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3': ['e7e5', 'c7c5', 'e7e6', 'c7c6'],
                'rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq d3': ['d7d5', 'g8f6', 'e7e6', 'c7c5']
            },

            pieces: {
                white: {
                    king: '♔', queen: '♕', rook: '♖', 
                    bishop: '♗', knight: '♘', pawn: '♙'
                },
                black: {
                    king: '♚', queen: '♛', rook: '♜', 
                    bishop: '♝', knight: '♞', pawn: '♟'
                }
            },

            // Professional piece-square tables for positional evaluation
            pieceSquareTables: {
                'p': [ // Pawn
                    0,  0,  0,  0,  0,  0,  0,  0,
                    50, 50, 50, 50, 50, 50, 50, 50,
                    10, 10, 20, 30, 30, 20, 10, 10,
                    5,  5, 10, 25, 25, 10,  5,  5,
                    0,  0,  0, 20, 20,  0,  0,  0,
                    5, -5,-10,  0,  0,-10, -5,  5,
                    5, 10, 10,-20,-20, 10, 10,  5,
                    0,  0,  0,  0,  0,  0,  0,  0
                ],
                'n': [ // Knight
                    -50,-40,-30,-30,-30,-30,-40,-50,
                    -40,-20,  0,  0,  0,  0,-20,-40,
                    -30,  0, 10, 15, 15, 10,  0,-30,
                    -30,  5, 15, 20, 20, 15,  5,-30,
                    -30,  0, 15, 20, 20, 15,  0,-30,
                    -30,  5, 10, 15, 15, 10,  5,-30,
                    -40,-20,  0,  5,  5,  0,-20,-40,
                    -50,-40,-30,-30,-30,-30,-40,-50
                ]
            },

            initGame() {
                this.setupBoard();
                this.renderBoard();
                this.updateStatus();
            },

            setupBoard() {
                this.board = [
                    ['r','n','b','q','k','b','n','r'],
                    ['p','p','p','p','p','p','p','p'],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    [null,null,null,null,null,null,null,null],
                    ['P','P','P','P','P','P','P','P'],
                    ['R','N','B','Q','K','B','N','R']
                ];
            },

            renderBoard() {
                const boardEl = document.getElementById('chess-board');
                boardEl.innerHTML = '';

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        square.onclick = () => this.handleSquareClick(row, col);

                        const piece = this.board[row][col];
                        if (piece) {
                            const pieceEl = document.createElement('div');
                            pieceEl.className = 'chess-piece';
                            pieceEl.textContent = this.getPieceSymbol(piece);
                            square.appendChild(pieceEl);
                        }

                        boardEl.appendChild(square);
                    }
                }
            },

            getPieceSymbol(piece) {
                const isWhite = piece === piece.toUpperCase();
                const type = piece.toLowerCase();
                const typeMap = {
                    'k': 'king', 'q': 'queen', 'r': 'rook',
                    'b': 'bishop', 'n': 'knight', 'p': 'pawn'
                };
                return this.pieces[isWhite ? 'white' : 'black'][typeMap[type]];
            },

            handleSquareClick(row, col) {
                const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                
                if (this.selectedSquare) {
                    if (this.selectedSquare.row === row && this.selectedSquare.col === col) {
                        this.clearSelection();
                        return;
                    }
                    
                    if (this.isValidMove(this.selectedSquare.row, this.selectedSquare.col, row, col)) {
                        this.makeMove(this.selectedSquare.row, this.selectedSquare.col, row, col);
                        this.clearSelection();
                        return;
                    }
                }

                if (this.board[row][col] && this.isPieceOwnedByCurrentPlayer(row, col)) {
                    this.selectSquare(row, col);
                }
            },

            selectSquare(row, col) {
                this.clearSelection();
                this.selectedSquare = { row, col };
                
                const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                square.classList.add('selected');
                
                this.possibleMoves = this.getPossibleMoves(row, col);
                this.possibleMoves.forEach(move => {
                    const moveSquare = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                    moveSquare.classList.add('possible-move');
                });
            },

            clearSelection() {
                document.querySelectorAll('.chess-square').forEach(square => {
                    square.classList.remove('selected', 'possible-move');
                });
                this.selectedSquare = null;
                this.possibleMoves = [];
            },

            isPieceOwnedByCurrentPlayer(row, col) {
                const piece = this.board[row][col];
                if (!piece) return false;
                
                const isWhitePiece = piece === piece.toUpperCase();
                return (this.currentPlayer === 'white' && isWhitePiece) || 
                       (this.currentPlayer === 'black' && !isWhitePiece);
            },

            isValidMove(fromRow, fromCol, toRow, toCol) {
                return this.possibleMoves.some(move => 
                    move.row === toRow && move.col === toCol);
            },

            getPossibleMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const type = piece.toLowerCase();
                const isWhite = piece === piece.toUpperCase();
                const moves = [];

                switch (type) {
                    case 'p': // Pawn
                        const direction = isWhite ? -1 : 1;
                        const startRow = isWhite ? 6 : 1;
                        
                        // Forward move
                        if (this.isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                            moves.push({ row: row + direction, col });
                            
                            // Double move from start
                            if (row === startRow && !this.board[row + 2 * direction][col]) {
                                moves.push({ row: row + 2 * direction, col });
                            }
                        }
                        
                        // Diagonal captures
                        [-1, 1].forEach(offset => {
                            const newCol = col + offset;
                            if (this.isInBounds(row + direction, newCol) && 
                                this.board[row + direction][newCol] && 
                                this.isPieceOwnedByCurrentPlayer(row + direction, newCol) !== 
                                this.isPieceOwnedByCurrentPlayer(row, col)) {
                                moves.push({ row: row + direction, col: newCol });
                            }
                        });
                        break;

                    case 'r': // Rook
                        this.addLineMoves(moves, row, col, [
                            [0, 1], [0, -1], [1, 0], [-1, 0]
                        ]);
                        break;

                    case 'n': // Knight
                        [
                            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                            [1, -2], [1, 2], [2, -1], [2, 1]
                        ].forEach(([dr, dc]) => {
                            const newRow = row + dr, newCol = col + dc;
                            if (this.isInBounds(newRow, newCol) && 
                                (!this.board[newRow][newCol] || 
                                 this.isPieceOwnedByCurrentPlayer(newRow, newCol) !== 
                                 this.isPieceOwnedByCurrentPlayer(row, col))) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        });
                        break;

                    case 'b': // Bishop
                        this.addLineMoves(moves, row, col, [
                            [1, 1], [1, -1], [-1, 1], [-1, -1]
                        ]);
                        break;

                    case 'q': // Queen
                        this.addLineMoves(moves, row, col, [
                            [0, 1], [0, -1], [1, 0], [-1, 0],
                            [1, 1], [1, -1], [-1, 1], [-1, -1]
                        ]);
                        break;

                    case 'k': // King
                        [
                            [0, 1], [0, -1], [1, 0], [-1, 0],
                            [1, 1], [1, -1], [-1, 1], [-1, -1]
                        ].forEach(([dr, dc]) => {
                            const newRow = row + dr, newCol = col + dc;
                            if (this.isInBounds(newRow, newCol) && 
                                (!this.board[newRow][newCol] || 
                                 this.isPieceOwnedByCurrentPlayer(newRow, newCol) !== 
                                 this.isPieceOwnedByCurrentPlayer(row, col))) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        });
                        break;
                }

                return moves;
            },

            addLineMoves(moves, row, col, directions) {
                directions.forEach(([dr, dc]) => {
                    let newRow = row + dr, newCol = col + dc;
                    
                    while (this.isInBounds(newRow, newCol)) {
                        if (this.board[newRow][newCol]) {
                            if (this.isPieceOwnedByCurrentPlayer(newRow, newCol) !== 
                                this.isPieceOwnedByCurrentPlayer(row, col)) {
                                moves.push({ row: newRow, col: newCol });
                            }
                            break;
                        }
                        moves.push({ row: newRow, col: newCol });
                        newRow += dr;
                        newCol += dc;
                    }
                });
            },

            isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            },

            makeMove(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
                const piece = this.board[fromRow][fromCol];
                const capturedPiece = this.board[toRow][toCol];
                const isCapture = !!capturedPiece;
                
                // Generate algebraic notation
                const moveNotation = this.generateAlgebraicNotation(fromRow, fromCol, toRow, toCol, piece, isCapture, promotionPiece);
                
                // Handle special moves
                this.handleSpecialMoves(fromRow, fromCol, toRow, toCol, piece);
                
                // Update captured pieces
                if (capturedPiece) {
                    const capturedColor = capturedPiece === capturedPiece.toUpperCase() ? 'white' : 'black';
                    this.capturedPieces[capturedColor === 'white' ? 'black' : 'white'].push(capturedPiece);
                }
                
                // Make the move
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = null;
                
                // Handle pawn promotion
                if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                    this.board[toRow][toCol] = promotionPiece || (this.currentPlayer === 'white' ? 'Q' : 'q');
                }
                
                // Update game state
                this.updateGameStateAfterMove(fromRow, fromCol, toRow, toCol, piece);
                
                // Record move in history
                this.gameState.moveHistory.push({
                    from: { row: fromRow, col: fromCol },
                    to: { row: toRow, col: toCol },
                    piece: piece,
                    captured: capturedPiece,
                    notation: moveNotation,
                    timestamp: Date.now()
                });
                
                this.moveCount++;
                this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                
                // Check for check, checkmate, stalemate
                this.analyzeGameState();
                
                this.renderBoard();
                this.updateStatus();
                this.playChessSound(isCapture ? 'capture' : 'move');
                
                if (this.aiEnabled && this.currentPlayer === 'black') {
                    setTimeout(() => this.makeAIMove(), 1200);
                }
            },

            // Professional algebraic notation generator
            generateAlgebraicNotation(fromRow, fromCol, toRow, toCol, piece, isCapture, promotionPiece) {
                const files = 'abcdefgh';
                const ranks = '87654321';
                
                const fromSquare = files[fromCol] + ranks[fromRow];
                const toSquare = files[toCol] + ranks[toRow];
                
                let notation = '';
                
                if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                    // Castling
                    notation = toCol > fromCol ? 'O-O' : 'O-O-O';
                } else {
                    // Regular move
                    if (piece.toLowerCase() !== 'p') {
                        notation += piece.toUpperCase();
                    }
                    
                    if (isCapture) {
                        if (piece.toLowerCase() === 'p') {
                            notation += files[fromCol];
                        }
                        notation += 'x';
                    }
                    
                    notation += toSquare;
                    
                    if (promotionPiece) {
                        notation += '=' + promotionPiece.toUpperCase();
                    }
                }
                
                return notation;
            },

            // Handle castling, en passant, and other special moves
            handleSpecialMoves(fromRow, fromCol, toRow, toCol, piece) {
                // Castling
                if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                    const isKingside = toCol > fromCol;
                    const rookFromCol = isKingside ? 7 : 0;
                    const rookToCol = isKingside ? 5 : 3;
                    
                    // Move the rook
                    this.board[fromRow][rookToCol] = this.board[fromRow][rookFromCol];
                    this.board[fromRow][rookFromCol] = null;
                }
                
                // En passant capture
                if (piece.toLowerCase() === 'p' && this.gameState.enPassantSquare && 
                    toRow === this.gameState.enPassantSquare.row && toCol === this.gameState.enPassantSquare.col) {
                    const capturedPawnRow = this.currentPlayer === 'white' ? toRow + 1 : toRow - 1;
                    this.board[capturedPawnRow][toCol] = null;
                }
            },

            // Update game state tracking
            updateGameStateAfterMove(fromRow, fromCol, toRow, toCol, piece) {
                // Update castling rights
                if (piece.toLowerCase() === 'k') {
                    if (this.currentPlayer === 'white') {
                        this.gameState.whiteKingMoved = true;
                    } else {
                        this.gameState.blackKingMoved = true;
                    }
                }
                
                if (piece.toLowerCase() === 'r') {
                    if (this.currentPlayer === 'white') {
                        if (fromCol === 0) this.gameState.whiteRooksMoved.queenside = true;
                        if (fromCol === 7) this.gameState.whiteRooksMoved.kingside = true;
                    } else {
                        if (fromCol === 0) this.gameState.blackRooksMoved.queenside = true;
                        if (fromCol === 7) this.gameState.blackRooksMoved.kingside = true;
                    }
                }
                
                // Update en passant square
                this.gameState.enPassantSquare = null;
                if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
                    this.gameState.enPassantSquare = {
                        row: (fromRow + toRow) / 2,
                        col: fromCol
                    };
                }
                
                // Update fifty-move rule
                if (piece.toLowerCase() === 'p' || this.board[toRow][toCol]) {
                    this.gameState.fiftyMoveRule = 0;
                } else {
                    this.gameState.fiftyMoveRule++;
                }
            },

            // Professional game state analysis
            analyzeGameState() {
                this.gameState.inCheck = this.isInCheck(this.currentPlayer);
                
                const legalMoves = this.getAllLegalMoves(this.currentPlayer);
                this.gameState.checkmate = this.gameState.inCheck && legalMoves.length === 0;
                this.gameState.stalemate = !this.gameState.inCheck && legalMoves.length === 0;
            },

            // Professional chess sound system
            playChessSound(type) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch (type) {
                    case 'move':
                        oscillator.frequency.setValueAtTime(700, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        break;
                    case 'capture':
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        break;
                    case 'check':
                        oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        break;
                }
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
            },

            makeAIMove() {
                const allMoves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (this.board[row][col] && this.isPieceOwnedByCurrentPlayer(row, col)) {
                            const moves = this.getPossibleMoves(row, col);
                            moves.forEach(move => {
                                allMoves.push({ 
                                    from: { row, col }, 
                                    to: { row: move.row, col: move.col } 
                                });
                            });
                        }
                    }
                }
                
                if (allMoves.length > 0) {
                    const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                    this.makeMove(randomMove.from.row, randomMove.from.col, 
                                 randomMove.to.row, randomMove.to.col);
                }
            },

            updateStatus() {
                document.getElementById('chess-current-player').textContent = 
                    this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1);
                document.getElementById('chess-move-count').textContent = this.moveCount;
                
                const totalCaptured = this.capturedPieces.white.length + this.capturedPieces.black.length;
                document.getElementById('chess-captured').textContent = totalCaptured;
                
                document.getElementById('chess-current-player').style.color = 
                    this.currentPlayer === 'white' ? '#e2e8f0' : '#94a3b8';
                
                // Update game status with professional analysis
                const statusElement = document.getElementById('chess-status');
                if (this.gameState.checkmate) {
                    const winner = this.currentPlayer === 'white' ? 'Black' : 'White';
                    statusElement.innerHTML = `🏆 Checkmate! ${winner} Wins!`;
                    statusElement.style.color = '#22c55e';
                    this.playChessSound('check');
                } else if (this.gameState.stalemate) {
                    statusElement.innerHTML = "🤝 Stalemate - It's a Draw!";
                    statusElement.style.color = '#f59e0b';
                } else if (this.gameState.inCheck) {
                    statusElement.innerHTML = `⚠️ ${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} King is in Check!`;
                    statusElement.style.color = '#ef4444';
                    this.playChessSound('check');
                } else {
                    statusElement.innerHTML = this.getLastMoveNotation();
                    statusElement.style.color = 'rgba(255, 255, 255, 0.9)';
                }
            },

            // Display last move in algebraic notation
            getLastMoveNotation() {
                const lastMove = this.gameState.moveHistory[this.gameState.moveHistory.length - 1];
                if (lastMove) {
                    return `Last Move: ${lastMove.notation}`;
                }
                return 'Ready to Play Professional Chess';
            },

            // Check if a king is in check
            isInCheck(color) {
                const kingPos = this.findKing(color);
                if (!kingPos) return false;
                
                const opponentColor = color === 'white' ? 'black' : 'white';
                return this.isSquareAttacked(kingPos.row, kingPos.col, opponentColor);
            },

            // Find king position
            findKing(color) {
                const kingSymbol = color === 'white' ? 'K' : 'k';
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (this.board[row][col] === kingSymbol) {
                            return { row, col };
                        }
                    }
                }
                return null;
            },

            // Check if a square is attacked by opponent
            isSquareAttacked(row, col, byColor) {
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = this.board[r][c];
                        if (piece && this.isPieceColor(piece, byColor)) {
                            const moves = this.getPossibleMoves(r, c);
                            if (moves.some(move => move.row === row && move.col === col)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            },

            // Check piece color
            isPieceColor(piece, color) {
                return color === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase();
            },

            // Get all legal moves for a color
            getAllLegalMoves(color) {
                const moves = [];
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.isPieceColor(piece, color)) {
                            const pieceMoves = this.getLegalMovesForPiece(row, col);
                            moves.push(...pieceMoves);
                        }
                    }
                }
                return moves;
            },

            // Get legal moves for a specific piece (excluding moves that leave king in check)
            getLegalMovesForPiece(row, col) {
                const possibleMoves = this.getPossibleMoves(row, col);
                const legalMoves = [];
                
                for (const move of possibleMoves) {
                    // Make temporary move
                    const originalPiece = this.board[move.row][move.col];
                    const movingPiece = this.board[row][col];
                    this.board[move.row][move.col] = movingPiece;
                    this.board[row][col] = null;
                    
                    // Check if this move leaves own king in check
                    const pieceColor = this.isPieceColor(movingPiece, 'white') ? 'white' : 'black';
                    if (!this.isInCheck(pieceColor)) {
                        legalMoves.push(move);
                    }
                    
                    // Restore board
                    this.board[row][col] = movingPiece;
                    this.board[move.row][move.col] = originalPiece;
                }
                
                return legalMoves;
            },

            newGame() {
                this.moveCount = 0;
                this.capturedPieces = 0;
                this.currentPlayer = 'white';
                this.clearSelection();
                this.setupBoard();
                this.renderBoard();
                this.updateStatus();
                document.getElementById('chess-status').textContent = '';
            },

            undoMove() {
                // Simple implementation - just restart
                this.newGame();
            },

            toggleAI() {
                this.aiEnabled = !this.aiEnabled;
                document.getElementById('chess-ai-status').textContent = 
                    this.aiEnabled ? 'AI: ON' : 'AI: OFF';
                
                if (this.aiEnabled && this.currentPlayer === 'black') {
                    setTimeout(() => this.makeAIMove(), 1000);
                }
            }
        };

        // Solitaire Game Logic
        const Solitaire = {
            deck: [],
            stock: [],
            waste: [],
            columns: [[], [], [], [], [], [], []],
            foundations: [[], [], [], []],
            moves: 0,
            score: 0,
            startTime: Date.now(),
            timer: null,
            draggedCard: null,
            draggedFrom: null,

            suits: ['♠', '♥', '♣', '♦'],
            values: ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'],
            suitColors: { '♠': 'black', '♥': 'red', '♣': 'black', '♦': 'red' },

            createCard(suit, value) {
                return {
                    suit: suit,
                    value: value,
                    color: this.suitColors[suit],
                    faceUp: false,
                    id: `${suit}-${value}`
                };
            },

            createDeck() {
                this.deck = [];
                for (let suit of this.suits) {
                    for (let value of this.values) {
                        this.deck.push(this.createCard(suit, value));
                    }
                }
                
                // Shuffle deck
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            },

            newGame() {
                this.createDeck();
                this.stock = [...this.deck];
                this.waste = [];
                this.columns = [[], [], [], [], [], [], []];
                this.foundations = [[], [], [], []];
                this.moves = 0;
                this.score = 0;
                this.startTime = Date.now();
                
                // Deal cards to columns
                for (let col = 0; col < 7; col++) {
                    for (let row = 0; row <= col; row++) {
                        const card = this.stock.pop();
                        if (row === col) card.faceUp = true;
                        this.columns[col].push(card);
                    }
                }
                
                this.updateDisplay();
                this.startTimer();
            },

            updateDisplay() {
                // Update stock
                const stockEl = document.getElementById('sol-stock');
                stockEl.innerHTML = this.stock.length > 0 ? 
                    '<div class="card face-down" style="position: static; margin: 0;">🂠</div>' : 
                    '<div style="color: rgba(255,255,255,0.6); font-size: 1.1rem; font-weight: 600;">Empty</div>';
                
                // Update waste
                const wasteEl = document.getElementById('sol-waste');
                wasteEl.innerHTML = '';
                if (this.waste.length > 0) {
                    const topCard = this.waste[this.waste.length - 1];
                    wasteEl.appendChild(this.createCardElement(topCard, 'waste'));
                }
                
                // Update foundations
                for (let i = 0; i < 4; i++) {
                    const foundationEl = document.getElementById(`sol-foundation-${i}`);
                    foundationEl.innerHTML = this.suits[i];
                    foundationEl.style.background = 'linear-gradient(145deg, rgba(34, 197, 94, 0.15) 0%, rgba(22, 163, 74, 0.15) 100%)';
                    foundationEl.style.border = '3px solid rgba(34, 197, 94, 0.4)';
                    foundationEl.style.borderRadius = '20px';
                    foundationEl.style.width = '110px';
                    foundationEl.style.height = '150px';
                    foundationEl.style.margin = '0 8px';
                    foundationEl.style.position = 'relative';
                    foundationEl.style.display = 'flex';
                    foundationEl.style.alignItems = 'center';
                    foundationEl.style.justifyContent = 'center';
                    foundationEl.style.fontSize = '3rem';
                    foundationEl.style.color = 'rgba(255, 255, 255, 0.5)';
                    foundationEl.style.backdropFilter = 'blur(10px)';
                    foundationEl.style.transition = 'all 0.3s ease';
                    
                    if (this.foundations[i].length > 0) {
                        const topCard = this.foundations[i][this.foundations[i].length - 1];
                        foundationEl.innerHTML = '';
                        foundationEl.appendChild(this.createCardElement(topCard, `foundation-${i}`));
                    }
                }
                
                // Update columns
                for (let col = 0; col < 7; col++) {
                    const columnEl = document.getElementById(`sol-column-${col}`);
                    columnEl.innerHTML = '';
                    
                    this.columns[col].forEach((card, index) => {
                        const cardEl = this.createCardElement(card, `column-${col}`);
                        cardEl.style.marginTop = `${index * 30}px`;
                        cardEl.style.position = 'absolute';
                        cardEl.style.top = `${index * 30}px`;
                        columnEl.appendChild(cardEl);
                    });
                }
                
                // Update stats
                document.getElementById('sol-moves-count').textContent = this.moves;
                document.getElementById('sol-score-count').textContent = this.score;
            },

            createCardElement(card, location) {
                const cardEl = document.createElement('div');
                cardEl.className = `card ${card.color}`;
                cardEl.draggable = card.faceUp;
                cardEl.dataset.cardId = card.id;
                cardEl.dataset.location = location;
                
                if (card.faceUp) {
                    cardEl.innerHTML = `
                        <div style="position: absolute; top: 4px; left: 6px; line-height: 1;">
                            <div style="font-size: 0.8rem; font-weight: 700;">${card.value}</div>
                            <div style="font-size: 0.9rem; margin-top: -2px;">${card.suit}</div>
                        </div>
                        <div style="position: absolute; bottom: 4px; right: 6px; line-height: 1; transform: rotate(180deg);">
                            <div style="font-size: 0.8rem; font-weight: 700;">${card.value}</div>
                            <div style="font-size: 0.9rem; margin-top: -2px;">${card.suit}</div>
                        </div>
                        <div class="card-value" style="margin-top: 8px;">${card.value}</div>
                        <div class="card-suit" style="margin-bottom: 8px;">${card.suit}</div>
                    `;
                    
                    cardEl.addEventListener('dragstart', (e) => {
                        this.draggedCard = card;
                        this.draggedFrom = location;
                        cardEl.style.opacity = '0.5';
                        e.dataTransfer.effectAllowed = 'move';
                    });
                    
                    cardEl.addEventListener('dragend', () => {
                        cardEl.style.opacity = '1';
                    });
                    
                    cardEl.addEventListener('dblclick', () => {
                        this.tryAutoMoveToFoundation(card, location);
                    });
                } else {
                    cardEl.classList.add('face-down');
                    cardEl.innerHTML = '<div style="font-size: 1.2rem; font-weight: bold;">🂠</div>';
                    
                    if (location.startsWith('column-')) {
                        const col = parseInt(location.split('-')[1]);
                        const cardIndex = this.columns[col].indexOf(card);
                        if (cardIndex === this.columns[col].length - 1) {
                            cardEl.addEventListener('click', () => this.flipCard(col));
                        }
                    }
                }
                
                return cardEl;
            },

            flipCard(col) {
                if (this.columns[col].length > 0) {
                    const topCard = this.columns[col][this.columns[col].length - 1];
                    if (!topCard.faceUp) {
                        topCard.faceUp = true;
                        this.moves++;
                        this.score += 5;
                        this.updateDisplay();
                    }
                }
            },

            drawCard() {
                if (this.stock.length > 0) {
                    const card = this.stock.pop();
                    card.faceUp = true;
                    this.waste.push(card);
                    this.moves++;
                    this.updateDisplay();
                } else if (this.waste.length > 0) {
                    // Reset stock from waste
                    this.stock = this.waste.reverse();
                    this.stock.forEach(card => card.faceUp = false);
                    this.waste = [];
                    this.moves++;
                    this.updateDisplay();
                }
            },

            allowDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.add('drop-zone');
            },

            dropCard(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('drop-zone');
                
                if (!this.draggedCard) return;
                
                const targetLocation = e.currentTarget.id.replace('sol-', '');
                
                if (this.isValidMove(this.draggedCard, this.draggedFrom, targetLocation)) {
                    this.makeSolitaireMove(this.draggedCard, this.draggedFrom, targetLocation);
                    this.updateDisplay();
                }
                
                this.draggedCard = null;
                this.draggedFrom = null;
            },

            isValidMove(card, from, to) {
                if (to.startsWith('foundation-')) {
                    const foundationIndex = parseInt(to.split('-')[1]);
                    const foundation = this.foundations[foundationIndex];
                    
                    if (foundation.length === 0) {
                        return card.value === 'A' && this.suits[foundationIndex] === card.suit;
                    } else {
                        const topCard = foundation[foundation.length - 1];
                        const cardValueIndex = this.values.indexOf(card.value);
                        const topValueIndex = this.values.indexOf(topCard.value);
                        return card.suit === topCard.suit && cardValueIndex === topValueIndex + 1;
                    }
                }
                
                if (to.startsWith('column-')) {
                    const colIndex = parseInt(to.split('-')[1]);
                    const column = this.columns[colIndex];
                    
                    if (column.length === 0) {
                        return card.value === 'K';
                    } else {
                        const topCard = column[column.length - 1];
                        const cardValueIndex = this.values.indexOf(card.value);
                        const topValueIndex = this.values.indexOf(topCard.value);
                        return card.color !== topCard.color && cardValueIndex === topValueIndex - 1;
                    }
                }
                
                return false;
            },

            makeSolitaireMove(card, from, to) {
                // Remove card from source
                if (from === 'waste') {
                    this.waste.pop();
                } else if (from.startsWith('column-')) {
                    const colIndex = parseInt(from.split('-')[1]);
                    this.columns[colIndex].pop();
                } else if (from.startsWith('foundation-')) {
                    const foundationIndex = parseInt(from.split('-')[1]);
                    this.foundations[foundationIndex].pop();
                }
                
                // Add card to destination
                if (to.startsWith('foundation-')) {
                    const foundationIndex = parseInt(to.split('-')[1]);
                    this.foundations[foundationIndex].push(card);
                    this.score += 10;
                } else if (to.startsWith('column-')) {
                    const colIndex = parseInt(to.split('-')[1]);
                    this.columns[colIndex].push(card);
                    this.score += 5;
                }
                
                this.moves++;
                
                // Check for auto-reveal
                if (from.startsWith('column-')) {
                    const colIndex = parseInt(from.split('-')[1]);
                    const column = this.columns[colIndex];
                    if (column.length > 0 && !column[column.length - 1].faceUp) {
                        column[column.length - 1].faceUp = true;
                        this.score += 5;
                    }
                }
                
                this.checkWinCondition();
            },

            tryAutoMoveToFoundation(card, from) {
                for (let i = 0; i < 4; i++) {
                    if (this.isValidMove(card, from, `foundation-${i}`)) {
                        this.makeSolitaireMove(card, from, `foundation-${i}`);
                        this.updateDisplay();
                        break;
                    }
                }
            },

            autoComplete() {
                let moved = true;
                while (moved) {
                    moved = false;
                    
                    // Try to move from waste
                    if (this.waste.length > 0) {
                        const wasteCard = this.waste[this.waste.length - 1];
                        for (let i = 0; i < 4; i++) {
                            if (this.isValidMove(wasteCard, 'waste', `foundation-${i}`)) {
                                this.makeSolitaireMove(wasteCard, 'waste', `foundation-${i}`);
                                moved = true;
                                break;
                            }
                        }
                    }
                    
                    // Try to move from columns
                    if (!moved) {
                        for (let col = 0; col < 7; col++) {
                            if (this.columns[col].length > 0) {
                                const topCard = this.columns[col][this.columns[col].length - 1];
                                if (topCard.faceUp) {
                                    for (let i = 0; i < 4; i++) {
                                        if (this.isValidMove(topCard, `column-${col}`, `foundation-${i}`)) {
                                            this.makeSolitaireMove(topCard, `column-${col}`, `foundation-${i}`);
                                            moved = true;
                                            break;
                                        }
                                    }
                                    if (moved) break;
                                }
                            }
                        }
                    }
                }
                
                this.updateDisplay();
            },

            undoMove() {
                if (this.moves > 0) {
                    this.newGame();
                }
            },

            checkWinCondition() {
                const totalFoundationCards = this.foundations.reduce((sum, foundation) => sum + foundation.length, 0);
                if (totalFoundationCards === 52) {
                    this.score += 1000;
                    setTimeout(() => {
                        alert('🎉 Congratulations! You won Solitaire!');
                    }, 500);
                }
            },

            startTimer() {
                if (this.timer) clearInterval(this.timer);
                
                this.timer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('sol-time-count').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }
        };

        // Global drag event handlers for solitaire
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
        });

        document.addEventListener('dragleave', (e) => {
            if (e.target.classList.contains('drop-zone')) {
                e.target.classList.remove('drop-zone');
            }
        });

        // Initialize the application
        window.addEventListener('DOMContentLoaded', function() {
            console.log('AI Games Hub by myOnsite Healthcare initialized successfully!');
        });
    </script>
</body>
</html> 